\documentclass[greek,booktabs,8pt,flagBlueCMYK]{report}
\usepackage{lscape}
\usepackage{isorot}
\usepackage{xkeyval}
\usepackage{polyglossia}
\usepackage{amsmath}

\newfontfamily\greekfont[Script=Greek]{Linux Libertine O}
\newfontfamily\greekfontsf[Script=Greek]{Linux Libertine O}

\setmainlanguage{greek}
\setotherlanguages{english}
\usepackage{fontspec}
\setmainfont[Kerning=On,Mapping=tex-text]{Minion Pro}

\usepackage[framed,numbered]{mcode}

\usepackage{geometry}

\usepackage{placeins}

\usepackage{float}

\usepackage{hyperref}
%\usepackage{mathtools}
\usepackage{graphicx}
\geometry{total={210mm,297mm},
left=20mm,right=20mm,
bindingoffset=10mm, top=20mm,bottom=20mm}

%TITLE
\title{Παράλληλη Επεξεργασία - Project \\ 2013 - 2014}
\author{Αγγελόπουλος Παναγιώτης ΑΜ. 946 \\ Μυσιρλίδης Χαράλαμπος ΑΜ. 949\\ Πλέσσας Κωνσταντίνος ΑΜ. 951}
\date{\parbox{\linewidth}{\centering%
  \today\endgraf\bigskip
  %A.M.: 946\endgraf\medskip
  e-mail:\{angelop,mysirlidis,kplessas\}@ceid.upatras.gr \endgraf
  \LaTeX \endgraf}}
%TITLE


\begin{document}

\maketitle

%CHAPTER
\makeatletter
\renewcommand{\@makechapterhead}[1]{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
  \hrule                                        % horizontal line
  \vspace{5pt}%                                 % add vertical space
  \interlinepenalty\@M
  \Huge \scshape #1\par                         % chapter title
  \vspace{5pt}%                                 % add vertical space
  \hrule                                        % horizontal rule
  \nobreak
  \vskip 40\p@
  }
}
\makeatother
%CHAPTER

%ROMAN NUM
\makeatletter
\newcommand*{\rom}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
%ROMAN NUM

\tableofcontents
\large
\chapter{Κεφάλαιο 1 - Εισαγωγικά}
\paragraph{\rom{1}.} Η εργασία πραγματοποιήθηκε με την χρήση του Intel i7-3770 CPU @ 3.40GHz με 8MB cache memory, λειτουργικό σύστημα Ubuntu 14.04 64-bit και 16gb RAM\newline

\paragraph{\rom{2}.}\textbf{Σημαντικές παρατηρήσεις:}\newline
Ο συγκεκριμένος επεξεργαστής περιλαμβάνει βασικά χαρακτηριστικά στοιχεία όπως αυτά αναφέρονται στον παρακάτω πίνακα : \newline 

\begin{center}
\begin{tabular}{ l | c }
  \hline
  Processor Number &	i7-3770 \\ \hline
  \# of Cores &	4 \\ \hline
  \# of Threads &	8 \\ \hline
  Clock Speed &	3.4 GHz \\ \hline
  Max Turbo Frequency &	3.9 GHz \\ \hline
  Instruction Set &	64-bit\\ \hline
  Instruction Set Extensions &	SSE4.1/4.2, AVX\\ \hline
  Intel® vPro Technology	& Yes\\ \hline
  Intel® Hyper-Threading Technology &	Yes\\ \hline
  Intel® Virtualization Technology (VT-x) & 	Yes\\ \hline
\end{tabular}
\end{center}

Κατά την εκτέλεση του προγράμματος παρατηρείται ότι ο επεξεργαστής μας χρησιμοποιεί διαφορετικό clock speed size (μέγεθος ταχύτητας ρολογιού) και πιο συγκεκριμένα όταν δοθεί η εντολή :
\begin{lstlisting}
  export OMP_NUM_THREADS = 1
\end{lstlisting}
τότε το clock speed size που χρησιμοποιείται είναι ίσο με 3.9 GHz. Η συγκεκριμένη συμπεριφορά του επεξεργαστή είναι κάτι απολύτως λογικό καθώς εξαιτίας του φράγματος που τοποθετούμε για την χρήση μόνο ενός νήματος, η ταχύτητα του ρολογίου αυξάνεται με στόχο την μείωση του χρόνου εκτέλεσης. 
\FloatBarrier
Παρόμοια συμπεριφορά πραγματοποιείται και με την επιλογή της χρήσης δύο νημάτων, όπου εκεί η ταχύτητα του ρολογιού μειώνεται στα 3.6 GHz. 
\FloatBarrier
Μετά την χρήση τεσσάρων νημάτων η ταχύτητα που επιτυγχάνει το ρολόι είναι και ταχύτητα που μας δείχνει ο πίνακας των χαρακτηριστικών του επεξεργαστή (3.4GHz).

%\begin{figure}[ht]
%\centering
%\includegraphics[width=0.76\textwidth]{erotima1.jpg}
%\caption{\textit{Το εύρος του χρονομετρητή \emph{tic-toc}}}
%\end{figure}

\clearpage
\chapter{Κεφάλαιο 2 - Serial}
\paragraph{\rom{1}.} \textbf{Σειριακή ανάλυση:}\newline
Από την ανάλυση που πραγματοποιήσαμε πάνω στο πρόγραμμα και με τη βοήθεια του scalasca γίνεται εύκολα αντιληπτό πως οι συναρτήσεις που καταναλώνουν τον περισσότερο χρόνο κατά την εκτέλεση του προγράμματος είναι οι εξής:
\begin{itemize}
  \item bmod ( double *a, double *b, double *c, long dimi, long dimj, long dimk, long stride )
  \item void daxpy ( double *a, double *b, long n, double alpha )
\end{itemize}
Όπως φαίνεται και στην παρακάτω εικόνα~\ref{fig:serial_1} (ανάλυση με scalasca) ο συνολικός χρόνος εκτέλεσης του προγράμματος είναι 2.36 δευτερόλεπτα με τις πιο βαριά υπολογιστικά συναρτήσεις να είναι οι παραπάνω. 
\FloatBarrier 
Η bmod καταναλώνει 1.06 και η daxpy  1.14

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{serial_1.png}
\caption{\textit{Ανάλυση χρόνου εκτέλεσης σειριακής έκδοσης προγράμματος}}
\label{fig:serial_1}
\end{figure}

\clearpage
\paragraph{\rom{2}.} \textbf{Συνάρτηση bmod:}\newline
Ο λόγος για τον οποίο η bmod καταναλώνει τον περισσότερο χρόνο έχει να κάνει με παράγοντες όπως:
\begin{itemize}
  \item data cache misses
  \item Σύνολο αναφορών στην μνήμη
  \item TLB misses
  \item Μεγάλου αριθμού πράξεων (κλήση της daxpy)
\end{itemize}
Πιο συγκεκριμένα, όταν το πρόγραμμά μας έχει πρόσβαση σε μία θέση μνήμης ή οποία δεν βρίσκεται στην κρυφή τότε έχουμε το λεγόμενο cache miss και το αίτημα εξυπηρετείται είτε από το επόμενο επίπεδο κρυφής μνήμης είτε απευθείας από την κύρια μνήμα. Στην περίπτωση που έχουμε cache miss είναι εμφανές ότι ο επεξεργαστής θα πρέπει να περιμένει να λάβει τα επιθυμητά στοιχεία αρκετό χρόνο πρωτού ξεκινήσει τις απαραίτητες διεργασίες και αυτό σαφώς επηρεάζει την απόδοση της εφαρμογής.
\\ \\
EIKONA 2
\\ \\
Ο αμέσως επόμενος παράγοντας είναι τα TLB misses.  Όπως γνωρίζουμε, μία CPU έχει μία κρυφή μνήμη που ονομάζεται TLB (Translation Lookaside Buffer) και η οποία είναι υπεύθυνη για μετάφραση της φυσικής μνήμης σε εικονική μνήμη και αποτελεί ξεχωριστή κρυφή μνήμη από τις υπόλοιπες επειδή είναι γρηγορότερο για την CPU να ψάξει μία θέση μνήμης εκεί απ’ότι σε μία άλλη κρυφή μνήμη. Η λειτουργικότητα του TLB φαίνεται στην παρακάτω 
εικόνα~\ref{fig:serial_3}. 

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{serial_3.jpg}
\caption{\textit{Translation Lookaside Buffer}}
\label{fig:serial_3}
\end{figure}

Όταν η εφαρμογή μας εκτελεί μία αναφορά σε θέση μνήμης, η εικονική διεύθυνση στέλνεται στο TLB για να καθοριστεί εφόσον και εάν περιέχεται μία μετάφραση για τη ζητούμενη διεύθυνση. Εφόσον υπάρχει τότε λέμε ότι έχουμε TLB hit και επιστρέφεται η ζητούμενη διεύθυνση. Εάν δεν υπάρχει τότε δημιουργείται TLB miss και η CPU ψάχνει απευθείας στον πίνακα σελίδων (page table) για τη μετάφραση καταναλώνοντας και εδώ πολύ περισσότερο χρόνο με αρνητική επίδραση στην απόδοση της εφαρμογής.  
\FloatBarrier 
Στην περίπτωση μας όπως φαίνεται και στην επόμενη σελίδα έχουμε σε αυτή τη συνάρτηση αρκετά TLB misses που ουσιαστικά επιδρούν στην απόδοση του προγράμματος. 
\\ \\
EIKONA 4
\\ \\
Επίσης, μία άλλη σημαντική παράμετρος που παρατηρούμε από την εκτέλεση του προγράμματος είναι πως ο χρόνος εκτέλεσης της bmod εξαρτάται σε πολύ μεγάλο βαθμό από το χρόνο εκτέλεσης της daxpy καθώς εκεί καλείται και τις περισσότερες φορές (τα loops είναι σαφώς περισσότερα από οπουδήποτε αλλού που καλείται η ίδια συνάρτηση.  

\paragraph{\rom{3}.} \textbf{Χρόνοι Σειριακής Εκτέλεσης Προγράμματος:}\newline

%\begin{figure}[H]
%\lstinputlisting{QR.m}
%\caption{Σύνταξη της QR.}
%\end{figure}


%\begin{figure}[h]
%\lstinputlisting{SVD.m}
%\caption{Σύνταξη της SVD.}
%\end{figure}

%\begin{figure}[h]
%\lstinputlisting{EIG.m}
%\caption{Σύνταξη της EIG.}
%\end{figure}

\clearpage
\chapter{Κεφάλαιο 3 - Παραλληλοποίηση με OpenMP (χωρίς SIMD εντολές)}
\paragraph{\rom{1}.} \textbf{Εισαγωγή:}\newline

Η επιλογή των OpenMP εντολών που θα χρησιμοποιήσουμε στον κώδικά μας πραγματοποιείται μετά την λεπτομερή ανάλυση του παραπάνω σειριακού προγράμματος.
Αρχικό μας μέλημα αποτελεί η χρήση των εντολών σε σημεία όπου θα μας παράξουν παράλληλα τμήματα εκτέλεσης του κώδικά μας και εμφανώς βελτιστοποιημένους χρόνους εκτέλεσης.

\paragraph{\rom{2}.} \textbf{Συναρτήσεις:}\newline
Οι συναρτήσεις οι οποίες και είναι υποψήφιες για παραλληλοποίηση είναι οι συναρτήσεις με τον μεγαλύτερο χρόνο εκτέλεσης. Έτσι η συνάρτηση bmod, 
η οποία και χρειάζεται 44,87\% του συνολικού χρόνου εκτέλεσης, καθώς και daxpy όπου και καλείται απο την συγκεκριμένη συνάρτηση χρειάζεται αντίστοιχα 40\%. 
% Θέλει αλλαγές και εικόνα με χρόνους εκτέλεσης.


\paragraph{\rom{3}.} \textbf{Παραλληλοποίηση:}\newline
Με βασικό στόχο την μείωση των παραπάνω χρόνων εκτέλεσης εφαρμόσαμε παραλληλισμό στα παραπάνω σημεία και καταφέραμε να μειώσουμε τον χρόνο που καταναλώνουν τα loops.

\chapter{Κεφάλαιο 4 - Παραλληλοποίηση με OpenMP και SIMD εντολές)}
\paragraph{\rom{1}.} \textbf{Εισαγωγή:}\newline




\end{document}
